---
title: java_简单排序算法
categories:
- java算法
tags:
- 后端
---
### 简单排序算法

简单排序一般指冒泡排序,选择排序,直接插入排序.

### 冒泡排序

冒泡排序（Bubble Sort）,是一种计算机科学领域的较简单的排序算法.
它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来.走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成.

比如12,10,18,6,21
第一次比较12与10,12比10大,交换两个位置,然后现在变成了10,12,18,6,21,然后继续比较12与18,18大于12,位置不变,还是12,10,18,6,21,接着比较18与6,18大于6,交换位置,变成12,10,6,18,21,然后比较18与21,21大,位置不变,现在就完成一次,将最大的移动到了最后,然后再从第一个开始,重复刚才的动作,总共会进行n(数组长度)-1次,第一次比较为n-1次,每进行一次,交换次数会相应减少一次.

冒泡排序的最佳时间复杂度为O(n),冒泡排序的最坏时间复杂度为O(n^2),冒泡排序总的平均时间复杂度为O(n^2),且冒泡排序是一种稳定排序算法。
``` bash
public class BubbleSort {
	public void Sort(int[] a){
		for (int i = 0; i < a.length-1; i++) {
			for (int j = 0; j < a.length-i-1; j++) {
				if(a[j]>a[j+1]){
					int temp=a[j];
					a[j]=a[j+1];
					a[j+1]=temp;		
				}
			}
		}
	}
}
```
测试:
``` bash
public class Test {
	public static void main(String[] args) {
		int[] a={12,10,18,6,21,133,56,0,2,32,65,52,24,34,57,24,39,25,100,598,014,23,42,2};
		new BubbleSort().Sort(a);
		for (int i : a) {
			System.out.print(i+",");
		}
	}
}
```
结果:0,2,2,6,10,12,12,18,21,23,24,24,25,32,34,39,42,52,56,57,65,100,133,598,

### 选择排序

对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个时为止。
比如12,10,18,6,21,
先将第一个数的下标存入index中,所以index=0,第一次在10,18,6,21中选出10与12比较,小的话就将10的下标1存入index中,此时index=1,然后18与10比较,就这样进行一轮,最后判断index下标是不是刚开始存入的值,不是的话交换位置,所以第一次过后为6,10,18,12,21,第二趟在18,12,21将index初始为1,和上面一样的方法,结果还为6,10,18,12,21,不断重复,直到排序完成.总共进行n-1次,第一次比较进行n-1次,每进行一次,比较次数会相应减少一次.

选择排序的最佳时间复杂度为O(n^2),选择排序的最坏时间复杂度为O(n^2),选择排序总的平均时间复杂度为O(n^2),且选择排序是一种不稳定排序算法。
``` bash
public class SelectionSort {
	public void sort(int[] a){
		for(int i=0;i<a.length-1;i++){
			int index=i;
			for(int j=i+1;j<a.length;j++){
				if(a[j]<a[index]){
					index=j;
				}
			}
			if(index!=i){
				int temp=a[i];
	            a[i]=a[index];
	            a[index]=temp;
			}
		}
	}
}
```
测试:
``` bash
public class Test {
	public static void main(String[] args) {
		int[] a={12,10,18,6,21,133,56,0,2,32,65,52,24,34,57,24,39,25,100,598,014,23,42,2};
		new SelectionSort().Sort(a);
		for (int i : a) {
			System.out.print(i+",");
		}
	}
}
```
结果:0,2,2,6,10,12,12,18,21,23,24,24,25,32,34,39,42,52,56,57,65,100,133,598,

### 直接插入排序

插入排序就是把当前待排序的元素插入到一个已经排好序的列表里面。就是右手抓取一张扑克牌，并把它插入左手拿着的排好序的扑克里面。

插入排序效率的最好情况运行时间为O(n),插入排序最坏情况运行时间和平均情况运行时间都为O(n^2).插入排序是稳定的算法

比如12,10,18,6,21, 
首先比较10小于12,所以将10放在一个临时变量中,将12后移一位,但由于此时空开的位置已经是第0个了,所以将10插入第0个位置,所以第一次下来为10,12,18,6,21,由于第二次18>12,所以位置不变,第三次,6小于18,所以将6放在一个临时变量中,将18向后移一位,由于12与10任大于6,所以它们分别向后移一位,由于此时空开的位置已经是第0个了,所以将6插入第0个位置,所以第三次下来为6,10,12,18,21,第四次由于21>18,所以不移,排序完成.

``` bash
public class InsertSort {
	public void sort(int[] a){
		for (int i = 1; i < a.length; i++) {
			int target=a[i];
			int j=i;
			while(j>0 && target<a[j-1]){
				a[j]=a[j-1];
				j--;
			}
			a[j] = target;
		}
	}
}
```
测试:
``` bash
public class Test {
	public static void main(String[] args) {
		int[] a={12,10,18,6,21,133,56,0,2,32,65,52,24,34,57,24,39,25,100,598,014,23,42,2};
		new InsertSort().Sort(a);
		for (int i : a) {
			System.out.print(i+",");
		}
	}
}
```
结果:0,2,2,6,10,12,12,18,21,23,24,24,25,32,34,39,42,52,56,57,65,100,133,598,

**若有不足,请批评指正**